### 设计模式一般遵循的设计原则
  
>---
#### 开闭原则 

**开闭原则** (The Open/Closed Principle，OCP) 规定 **软件中的对象 (类，模块，函数等等) 应该对于扩展是开放的，但是对于修改是封闭的**。开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性，提高代码的可复用性。

可以通过 “**抽象约束、封装变化**” 来实现开闭原则，通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

>---
#### 里氏替换原则

**里氏替换原则** (Liskov Substitution Principle，LSP) 描述为 **派生类 (子类) 对象可以在程序中代替其基类 (超类) 对象**。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。

里氏替换原则通俗来讲就是：**子类可以扩展父类的功能，但不能改变父类原有的功能**。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不重写父类的方法。

>---
#### 依赖倒置原则

**依赖倒置原则** (Dependence Inversion Principle，DIP) 描述 **程序要依赖于抽象接口，不要依赖于具体实现**。依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。

依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以在实际编程中遵循：每个类尽量提供接口或抽象类，或者两者都具备；变量的声明类型尽量是接口或者是抽象类；任何类都不应该从具体类派生；使用继承时尽量遵循里氏替换原则。

>---
#### 单一职责原则

**单一职责原则** (Single Responsibility Principle，SRP) 规定 **一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分**。单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。单一职责原降低了类的复杂度。**一个类只负责一项职责**；提高了类的可读性和系统的可维护性。

单一职责原则是将类的不同职责分离，再封装到不同的类或模块中。

>---
#### 接口隔离原则

**接口隔离原则** (Interface Segregation Principle，ISP) 要求程序员尽量 **将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法**。接口隔离原则的定义是：客户端不应该被迫依赖于它不使用的方法 (该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上) 。

接口隔离原则提高类的内聚性、降低它们之间的耦合性，体现了封装的思想：注重的是对接口依赖的隔离和约束接口，主要针对抽象和程序整体框架的构建。在具体应用接口隔离原则时，应该根据以下几个规则来衡量：
  - 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
  - 为依赖接口的类定制服务。只提供调用方需要的方法，屏蔽不需要的方法。
  - 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同。
  - 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

>---
#### 迪米特原则

**迪米特法则** (Law of Demeter，LoD) 又叫作最少知识原则 (Least Knowledge Principle，LKP)。**迪米特法则的定义** 是：只与直接朋友交谈，不跟 “陌生人” 说话。其含义是：**如果两个程序实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用**。其目的是降低类之间的耦合度，提高模块的相对独立性。**朋友** 是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。

从迪米特法则的定义和特点可知，从依赖者的角度来说，只依赖应该依赖的对象；从被依赖者的角度说，只暴露应该暴露的方法。在运用迪米特法则时要注意：
- 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
- 在类的结构设计上，尽量降低类成员的访问权限。在类的设计上，优先考虑将一个类设置成不变类。
- 在对其他类的引用上，将引用其他对象的次数降到最低。
- 不暴露类的属性成员，而应该提供相应的访问器 (set 和 get 方法) 。
- 谨慎使用序列化 (Serializable) 功能。

>---
#### 合成复用原则

**合成复用原则** (Composite Reuse Principle，CRP) 又叫组合 / 聚合复用原则 (Composition/Aggregate Reuse Principle，CARP)。**合成复用要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现**。

合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。

---