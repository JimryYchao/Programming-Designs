### 设计模式怎样解决设计问题

对象通过实例化类来创建，此对象被称为该类的实例；当实例化类时，要给对象的内部数据 (由实例变量组成) 分配内存空间、并将操作与这些数据联系起来。

抽象类 (abstract class) 的只要目的是为它的子类定义公共接口，一个抽象类将它的部分或全部操作的实现延时到子类。混入类 (mixin class) 是给其他类提供可选择的接口或功能的类，混入类要求多继承。

类继承与接口继承之间的区别：类继承根据一个对象的实现定义了另一个对象的实现，它是代码和表示的共享机制；接口继承描述了一个对象什么时候能够被用来替代另一个对象。

> **运用复用机制**

面向对象系统中功能复用最常用的技术是类继承和对象组合。通过生成子类的复用被称为白箱复用 (white-box reuse) ，即在继承方式中，父类的内部细节对子类可见。新的更复杂的功能可以通过组装或组合对象来获得，对象组合要求被组合的对象具有良好定义的接口，这种复用方式被称为黑箱复用 (black-box reuse) ，对象的内部细节是不可见的。

类继承在编译时就定义了，因此无法在运行时改变从父类继承的实现，继承常被认为是 “破坏了封装性”，子类与父类之间的耦合性很高；对象组合是通过获得对其他对象的引用而在运行时刻动态定义的，对象只通过接口访问，因此保护了对象的封装性。

理论上优先使用对象组合而不是类继承，但常常将继承与对象组合一起使用。

委托 (delegation) 是一种组合方法；在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给它的代理者 (delegate)。

> **关联运行时刻和编译时刻的结构**

聚合 (aggregation) 意味着一个对象拥有另一个对象或对另一个对象负责，聚合意味着聚合对象和其拥有者具有相同的生命周期。

相识 (acquaintance)  (或关联、引用关系) 意味着一个对象仅仅知道另一个对象，相识的对象可能请求彼此的操作，但相互之间不为对方负责，它只标识了对象间较松散的耦合关系。

> **设计应支持变化**

获得最大限度复用的关键在于对新需求和已有需求发生变化时的预见性，要求设计的系统能够相应地改进。

以下是常见一些导致重新设计的一般原因，以及解决这些问题的设计模式：

- 通过显式地指定一个类来创建对象：在创建对象时指定类名将受特定实现的约束而不是特定接口的约束，这会使未来的变化更复杂。为避免这类情况，应间接地创建对象。
  设计模式：Abstract Factory、Factory Method、Prototype 

+ 对特殊操作的依赖：当为一个请求指定一个特殊操作时，完成该请求的方式被固化。为避免将请求代码写死，可以在编译时或运行时灵活地改变响应请求的方法。
  设计模式：Chain of Responsibility、Command
 
- 对硬件和软件平台的依赖：外部的操作系统接口和应用编程接口 (API) 在不同的软硬件平台上是不同的。依赖于特定平台的软件将不具有可移植性。所以设计系统时限制其平台相关性就很重要了。
  设计模式：Abstract Factory、Bridge
  
+ 对对象表示或实现的依赖：知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能够阻止连锁变化。
  设计模式：Abstract Factory、Bridge、Memento、Proxy

- 算法依赖：算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。
  设计模式：Builder、Iterator、Strategy、Template Method、Visitor
 
+ 紧耦合：紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，必须要理解和改变其他许多类。这样的系统是很难维护和移植的密集体。松散耦合提高了一个类本身被复用的可能性，并且系统更容易移植、修改和扩展。设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。
  设计模式：Abstract Factory、Command、Facade、Mediator、Observer、Chain of Responsibility
 
- 通过生成子类来扩充功能：通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销。定义子类还需要对父类有深入的了解。一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方法。新的功能可以通过以新的方式组合已有的对象，而不是通过定义已存在类的子类的方式加到应用中去。在许多的设计中，可以通过定义一个子类，且将它的实例和已存在的实例进行组合来引入定制的功能。
  设计模式：Bridge、Chain of Responsibility、Composite、Decorator、Observer、Strategy
 
+ 不能方便地对类进行修改：有时候不得不改变一个难以修改的类。也许是需要源代码却又没有提供的功能，或者可能对类的任何更改会要求更改需要已存在的其他子类。设计模式提供在这些情况下对类进行修改的方法。
  设计模式：Adapter、Decorator、Visitor

---