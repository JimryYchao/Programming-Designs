### 创建型模式
#### 类创建模式

使用 Factory Method 类创建模式创建类的子类，其主要缺点是仅为了改变产品类，就可能需要创建一个新的子类，且这样的改变可能是级联的，新增子类的同时还需要重定义其产品的创建者。

>---
#### 对象复合创建模式

定义一个对象负责明确产品对象的类，并将它作为该系统的参数，这是 AbstractFactory、Builder 和 Prototype 的关键特征。

它们都涉及到创建一个新的负责产品对象的 “工厂对象”：
  - AbstractFactory 产生多个类的对象。
  - Builder 使用一个相对复杂的协议，逐步创建一个复杂产品。
  - Prototype 通过拷贝原型对象来创建产品对象。

>---
#### 有关创建型模式的讨论

- Singleton 模式解决的是实体对象个数的问题。除了 Singleton 之外，其他创建型模式解决的都是 new 所带来的耦合关系。
- Factory Method, Abstract Factory, Builder 都需要一个额外的工厂类来负责实例化 “易变对象”。
- Prototype 则是通过原型 (一个特殊的工厂类) 来克隆 “易变对象”。
- 如果遇到 “易变类”，起初的设计通常从 Factory Method 开始，当遇到更多的复杂变化时，再考虑重构为其他三种工厂模式 (Abstract Factory，Builder，Prototype)。

---
### 结构型模式
#### Adapter 与 Bridge

- 两者都给另一个对象提供了一定程度上的间接性，有利于系统的灵活性，但两者通常被用于软件生命周期的不同阶段。
- Adapter 主要为了解决两个已有接口之间不匹配的问题，在设计类之后实施；Bridge 对抽象接口与它的实现部分进行桥接，在设计类之前实施。
- Facade 定义一个新的接口，Adapter 是复用一个原有的接口。
  
>---
#### Composite、Decorator 与 Proxy

- Composite 与 Decorator 有相似的结构图，它们都是基于递归组合来组织可变数目的对象。
- Decorator 能够不需要生成子类即可给对象添加职责；Composite 创造类，使得多个相关的对象能够以统一的方式处理，将多重对象当作一个对象来处理。
- Decorator 与 Proxy 一样，在构成对象时为用户提供一致的接口，但 Proxy 不能动态地添加或分离性质，它的目的是在访问一个对象不方便或不符合需求时，为这个实体提供一个替代者。
- Proxy 对实体提供访问，Decorator 对对象提供组件功能。

---
### 行为型模式
#### 封装变化

封装变化是很多行为型模式的主题，它们通常定义一个抽象类来描述这些封装变化的对象：
  1. Strategy 对象封装一个算法。
  2. State 对象封装一个与状态相关的算法。
  3. Mediator 对象封装对象间的协议。
  4. Iterator 对象封装访问和遍历一个聚合对象中的各个构件的方法。
  
>---
#### 对象作为参数

一些模式引入总是被用作参数的对象。
  1. Visitor 对象是一个多态的 Accept 操作的参数。
  2. Command 对象作为标记 (令牌) 代表一个请求。
  3. Memento 中作为一个对象在某个特定时刻的内部状态。

>---
#### 通信应该被封装还是被分布

Mediator 和 Observer 是相互竞争的模式：Observer 通过引入 Observer 和 Subject 对象来分布通信，Mediator 对象则封装了其他对象间的通信。

>---
#### 对发送者和接收者解耦

- Command 模式使用一个 Command 对象来定义一个发送者和一个接受者之间的绑定关系。
- Observer 模式通过定义一个接口来通知目标中发生的改变，从而将发送者 (目标) 与接收者 (观察者) 解耦。
- 中介者模式让对象通过一个 Mediator 对象间接的互相引用，从而对它们解耦。
- 职责链模式通过沿一个潜在接收者链传递请求而将发送者与接收者解耦。

---